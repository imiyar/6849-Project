// Generated by CoffeeScript 1.12.5
(function() {
  var CPAssignMV, RBTree, assign, checkCycles, checkFlatFoldability, clean, clearSVG, computeAngle, creasePattern, data, disableAddVertex, disableClickEvent, disableMoveVertex, downloadCP, edgeNum, enableAddBoundary, enableAddCrease, enableAddVertex, enableDeleteElt, enableMoveVertex, equalAnglesCrimp, findPairs, findSwaps, firstEdge, firstVert, getEdge, getEqualAngles, getNonBoundVert, graphlib, importFile, isLocalMin, kawasakiCheck, length, makeCopy, makeCycList, makeData, makeFace, makeGraph, moveVert, same, sameLength, singleCrimp, singleVertAssignMV, solve, swapPairs, updateEqualAngles, vertexNum, xValue, yValue, yallist,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  getEdge = function(verticesNum, edges_vertices) {
    var edge, i, j, k, len, ref, vertices;
    vertices = {};
    for (i = j = 0, ref = verticesNum - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      vertices[i] = [];
    }
    i = 0;
    for (k = 0, len = edges_vertices.length; k < len; k++) {
      edge = edges_vertices[k];
      vertices[edge[0]].push([edge[1], i]);
      vertices[edge[1]].push([edge[0], i]);
      i += 1;
    }
    return vertices;
  };

  getNonBoundVert = function(edges_assignment, verticesNum, vertices, edges_vertices) {
    var edge, i, isBoundary, j, k, len, len1, m, nonBoundVert, ref, ref1, v, vertIndex;
    isBoundary = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = verticesNum.length; j < len; j++) {
        v = verticesNum[j];
        results.push(false);
      }
      return results;
    })();
    for (i = j = 0, len = edges_assignment.length; j < len; i = ++j) {
      edge = edges_assignment[i];
      if (edge === 'B') {
        isBoundary[edges_vertices[i][0]] = true;
        isBoundary[edges_vertices[i][1]] = true;
      }
    }
    nonBoundVert = {};
    for (vertIndex = k = 0, ref = verticesNum - 1; 0 <= ref ? k <= ref : k >= ref; vertIndex = 0 <= ref ? ++k : --k) {
      if (!isBoundary[vertIndex]) {
        nonBoundVert[vertIndex] = [];
        ref1 = vertices[vertIndex];
        for (m = 0, len1 = ref1.length; m < len1; m++) {
          edge = ref1[m];
          nonBoundVert[vertIndex].push({
            start: vertIndex,
            end: edge[0],
            angle: 0,
            id: edge[1]
          });
        }
      }
    }
    return nonBoundVert;
  };

  computeAngle = function(nonBoundVert, vertices_coords) {
    var angle, angles, edge, edges, i, j, k, len, len1, len2, m, theta, v, vertIndex, x, y;
    for (vertIndex in nonBoundVert) {
      edges = nonBoundVert[vertIndex];
      for (i = j = 0, len = edges.length; j < len; i = ++j) {
        edge = edges[i];
        v = edge.end;
        x = vertices_coords[v][0] - vertices_coords[vertIndex][0];
        y = vertices_coords[v][1] - vertices_coords[vertIndex][1];
        theta = x === 0 ? Math.PI / 2 : Math.atan(y / x);
        if ((x < 0) || (x === 0 && y < 0)) {
          theta += Math.PI;
        }
        edge.angle = Number((theta * 180 / Math.PI).toFixed(1));
      }
      edges.sort(function(a, b) {
        return a.angle - b.angle;
      });
      angles = [];
      for (i = k = 0, len1 = edges.length; k < len1; i = ++k) {
        edge = edges[i];
        angle = i !== 0 ? edge.angle - edges[i - 1].angle : edge.angle - (edges[edges.length - 1].angle - 360);
        angles.push(angle);
      }
      for (i = m = 0, len2 = edges.length; m < len2; i = ++m) {
        edge = edges[i];
        edge.angle = angles[i];
      }
    }
    return nonBoundVert;
  };

  kawasakiCheck = function(nonBoundVert) {
    var edge, edgeNum, edges, even, i, j, len, odd, vertIndex;
    for (vertIndex in nonBoundVert) {
      edges = nonBoundVert[vertIndex];
      edgeNum = edges.length;
      if (edgeNum % 2 !== 0) {
        alert("Not Flat-foldable! There is an odd number of crease around vertex " + vertIndex + ".");
        return false;
      }
    }
    for (vertIndex in nonBoundVert) {
      edges = nonBoundVert[vertIndex];
      even = odd = 0;
      for (i = j = 0, len = edges.length; j < len; i = ++j) {
        edge = edges[i];
        if (i % 2 === 0) {
          even += edge.angle;
        }
        if (i % 2 !== 0) {
          odd += edge.angle;
        }
      }
      if (even !== odd) {
        alert("Not Flat-foldable! Angles around vertex " + vertIndex + " violate Kawasaki's theorem.");
        return false;
      }
    }
    return true;
  };

  equalAnglesCrimp = function(num, node, bool) {
    var head, i, j, k, numM, ref, ref1;
    node = node.prev;
    head = node.prev;
    if (bool) {
      numM = Math.floor(num / 2) + 1;
    } else {
      if (num % 2 !== 0) {
        num += 1;
      }
      numM = Math.floor(num / 2);
    }
    if (numM > 0) {
      for (i = j = 1, ref = numM; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        edges_assignment[node.value.id] = "M";
        node = node.next;
      }
    }
    if (num - numM > 0) {
      for (i = k = 1, ref1 = num - numM; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
        edges_assignment[node.value.id] = "V";
        node = node.next;
      }
    }
    head.next = node;
    return node.prev = head;
  };

  makeCycList = function(elts) {
    var list;
    list = yallist(elts);
    list.tail.next = list.head;
    list.head.prev = list.tail;
    return list;
  };

  getEqualAngles = function(length, head) {
    var angles, count, i, j, node, ref;
    angles = [];
    node = head;
    count = 1;
    for (i = j = 1, ref = length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      if (node.value.angle === node.next.value.angle) {
        count += 1;
      } else {
        angles.push({
          number: count,
          head: head,
          angle: head.value.angle
        });
        head = node.next;
        count = 1;
      }
      node = node.next;
    }
    return angles;
  };

  isLocalMin = function(node) {
    return node.value.angle < node.prev.value.angle && node.value.angle < node.next.value.angle;
  };

  updateEqualAngles = function(now) {
    var angle;
    if (now.value.number % 2 === 0) {
      if (now.prev !== now.next && now.prev.value.angle === now.next.value.angle) {
        now.prev.value.number += now.next.value.number;
        now.prev.next = now.next.next;
        now.next.next.prev = now.prev;
      } else {
        now.prev.next = now.next;
        now.next.prev = now.prev;
      }
      return now.prev;
    } else {
      angle = now.prev.value.angle - now.value.angle + now.next.value.angle;
      now.value = {
        number: 1,
        head: now.value.head,
        angle: angle
      };
      now.prev.value.number -= 1;
      now.next.value.number -= 1;
      if (now.prev.value.number === 0) {
        now.prev.prev.next = now;
        now.prev = now.prev.prev;
      }
      if (now.next.value.number === 0) {
        now.next.next.prev = now;
        now.next = now.next.next;
      } else {
        now.next.value.head = now.next.value.head.next;
      }
      if (now.prev !== now && now.prev.value.angle === now.value.angle) {
        now.prev.value.number += now.value.number;
        now.prev.next = now.next;
        now.next.prev = now.prev;
        now = now.prev;
      }
      if (now !== now.next && now.value.angle === now.next.value.angle) {
        now.value.number += now.next.value.number;
        now.next = now.next.next;
        now.next.next.prev = now;
      }
      return now;
    }
  };

  assign = function(head, localMin) {
    var newNode, now;
    if (head.next === head) {
      return equalAnglesCrimp(head.value.number, head.value.head, true);
    } else {
      now = localMin.shift();
      equalAnglesCrimp(now.value.number, now.value.head, false);
      newNode = updateEqualAngles(now);
      if (isLocalMin(newNode)) {
        localMin.push(newNode);
      }
      if (isLocalMin(newNode.next)) {
        localMin.push(newNode.next);
      }
      if (isLocalMin(newNode.prev)) {
        localMin.push(newNode.prev);
      }
      return assign(newNode, localMin);
    }
  };

  singleVertAssignMV = function(nonBoundVert) {
    var angleList, angles, edges, head, i, j, list, localMin, node, ref, results, vertIndex;
    results = [];
    for (vertIndex in nonBoundVert) {
      edges = nonBoundVert[vertIndex];
      list = makeCycList(edges);
      head = list.head;
      if (head.value.angle === head.next.value.angle) {
        head = head.next;
        while (head !== list.head) {
          if (head.value.angle === head.next.value.angle) {
            head = head.next;
          } else {
            break;
          }
        }
      }
      head = head.next;
      angles = getEqualAngles(list.length, head);
      angleList = makeCycList(angles);
      localMin = [];
      node = angleList.head;
      for (i = j = 1, ref = angles.length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        if (isLocalMin(node)) {
          localMin.push(node);
        }
        node = node.next;
      }
      results.push(assign(angleList.head, localMin));
    }
    return results;
  };

  singleCrimp = function(node, BST) {
    var angle, head;
    BST.remove(node);
    BST.remove(node.prev);
    if (node.prev === node.next) {
      return [node.value.id, node.prev.value.id, 1];
    } else {
      BST.remove(node.next);
      angle = node.prev.value.angle - node.value.angle + node.next.value.angle;
      node.next.value.angle = angle;
      BST.insert(node.next);
      head = node.prev.prev;
      head.next = node.next;
      node.next.prev = head;
      return [node.value.id, node.prev.value.id, -1];
    }
  };

  makeCopy = function(nonBoundVert_0) {
    var edge, edgeList, edges, i, j, len, newEdge, nonBoundVert, vertIndex;
    nonBoundVert = {};
    edgeList = {};
    for (vertIndex in nonBoundVert_0) {
      edges = nonBoundVert_0[vertIndex];
      nonBoundVert[vertIndex] = [];
      for (i = j = 0, len = edges.length; j < len; i = ++j) {
        edge = edges[i];
        newEdge = {
          start: nonBoundVert_0[vertIndex][i].start,
          end: nonBoundVert_0[vertIndex][i].end,
          angle: nonBoundVert_0[vertIndex][i].angle,
          id: nonBoundVert_0[vertIndex][i].id
        };
        nonBoundVert[vertIndex].push(newEdge);
        edgeList[newEdge.id] = newEdge;
      }
    }
    return [nonBoundVert, edgeList];
  };

  findPairs = function(nonBoundVert) {
    var RBT, edges, head, list, minima, node, pairs, vertIndex, vertList;
    vertList = {};
    for (vertIndex in nonBoundVert) {
      edges = nonBoundVert[vertIndex];
      list = makeCycList(edges);
      head = list.head;
      vertList[vertIndex] = head;
    }
    RBT = new RBTree(function(l, r) {
      if (l.value.angle !== r.value.angle) {
        return l.value.angle - r.value.angle;
      } else {
        return l.value.end - r.value.end;
      }
    });
    for (vertIndex in vertList) {
      head = vertList[vertIndex];
      RBT.insert(head);
      node = head.next;
      while (node !== head) {
        RBT.insert(node);
        node = node.next;
      }
    }
    pairs = [];
    minima = RBT.min();
    while (minima !== null) {
      pairs.push(singleCrimp(minima, RBT));
      minima = RBT.min();
    }
    return pairs;
  };

  checkCycles = function(components, g) {
    var component, cycle, cycles, flag, i, isPath, j, k, len, len1, len2, len3, m, n, vert;
    cycles = [];
    for (j = 0, len = components.length; j < len; j++) {
      component = components[j];
      isPath = false;
      if (component.length >= 3) {
        for (k = 0, len1 = component.length; k < len1; k++) {
          vert = component[k];
          if (g.neighbors(vert).length === 1) {
            isPath = true;
            break;
          }
        }
        if (!isPath) {
          cycles.push(component);
        }
      }
    }
    for (m = 0, len2 = cycles.length; m < len2; m++) {
      cycle = cycles[m];
      flag = 1;
      for (i = n = 0, len3 = cycle.length; n < len3; i = ++n) {
        vert = cycle[i];
        flag *= i === 0 ? g.edge({
          v: vert,
          w: cycle[cycle.length - 1]
        }) : g.edge({
          v: vert,
          w: cycle[i - 1]
        });
      }
      if (flag < 0) {
        return false;
      }
    }
    return true;
  };

  findSwaps = function(vertList) {
    var head, node, swaps, vertIndex;
    swaps = [];
    for (vertIndex in vertList) {
      head = vertList[vertIndex];
      if (head.value.angle === head.next.value.angle) {
        swaps.push([head.prev.value.id, head.next.value.id]);
      }
      node = head.next;
      while (node !== head) {
        if (node.value.angle === node.next.value.angle) {
          swaps.push([node.prev.value.id, node.next.value.id]);
        }
        node = node.next;
      }
    }
    console.log(swaps);
    return swaps;
  };

  swapPairs = function(pairs, swap, edgeList) {
    var edge1, edge2, elt, first, firsts, j, k, len, len1, len2, m, pair, pos1, pos2, ref, ref1, second, seconds;
    firsts = [];
    seconds = [];
    for (j = 0, len = pairs.length; j < len; j++) {
      pair = pairs[j];
      if ((ref = swap[0]) === pair[0] || ref === pair[1]) {
        firsts.push(pair);
      } else if ((ref1 = swap[1]) === pair[0] || ref1 === pair[1]) {
        seconds.push(pair);
      }
    }
    for (k = 0, len1 = firsts.length; k < len1; k++) {
      first = firsts[k];
      if (first[0] === swap[0]) {
        pos1 = 0;
        edge1 = first[1];
      } else {
        pos1 = 1;
        edge1 = first[0];
      }
      for (m = 0, len2 = seconds.length; m < len2; m++) {
        second = seconds[m];
        if (second[0] === swap[1]) {
          pos2 = 0;
          edge2 = second[1];
        } else {
          pos2 = 1;
          edge2 = second[0];
        }
        if (edgeList[edge1].start === edgeList[edge2].start || edgeList[edge1].start === edgeList[edge2].end || edgeList[edge1].end === edgeList[edge2].start || edgeList[edge1].end === edgeList[edge2].end) {
          elt = first[pos1];
          first[pos1] = second[pos2];
          second[pos2] = elt;
          return pairs;
        }
      }
    }
  };

  makeGraph = function(pairs) {
    var g, j, len, pair;
    g = new graphlib.Graph({
      directed: false
    });
    for (j = 0, len = pairs.length; j < len; j++) {
      pair = pairs[j];
      g.setEdge(pair[0], pair[1], pair[2]);
    }
    return g;
  };

  checkFlatFoldability = function(nonBoundVert, pairs) {
    var components, edgeNum, edges, g, head, j, len, list, numComp, swap, swaps, vertIndex, vertList;
    g = makeGraph(pairs);
    edgeNum = g.nodeCount();
    components = graphlib.alg.components(g);
    numComp = components.length;
    if (!checkCycles(components, g)) {
      vertList = {};
      for (vertIndex in nonBoundVert) {
        edges = nonBoundVert[vertIndex];
        list = makeCycList(edges);
        head = list.head;
        vertList[vertIndex] = head;
      }
      swaps = findSwaps(vertList);
      for (j = 0, len = swaps.length; j < len; j++) {
        swap = swaps[j];
        pairs = swapPairs(pairs, swap, edgeList);
        g = makeGraph(pairs);
        console.log(components = graphlib.alg.components(g));
        if (components.length < numComp) {
          numComp = components.length;
          if (checkCycles(components, g)) {
            return [true, components, g];
          }
        } else {
          pairs = swapPairs(pairs, swap, edgeList);
        }
      }
      alert("No locally flat-foldable mountain–valley assignment!");
      return [false, null, null];
    }
    return [true, components, g];
  };

  CPAssignMV = function(edges_assignment, components, g) {
    var assignMV, component, j, len, results;
    results = [];
    for (j = 0, len = components.length; j < len; j++) {
      component = components[j];
      assignMV = function(node, label) {
        var k, len1, neighbor, neighbors, nextLabel, results1;
        edges_assignment[node] = label === 1 ? "M" : "V";
        neighbors = g.neighbors(node);
        results1 = [];
        for (k = 0, len1 = neighbors.length; k < len1; k++) {
          neighbor = neighbors[k];
          if (edges_assignment[neighbor] === "U") {
            nextLabel = g.edge(node, neighbor);
            results1.push(assignMV(neighbor, label * nextLabel));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      };
      results.push(assignMV(component[0], 1));
    }
    return results;
  };

  yallist = require("yallist");

  RBTree = require("bintrees").RBTree;

  graphlib = require("graphlib");

  solve = function(creasePattern) {
    var components, edge, edgeList, edges_assignment, edges_vertices, flatFoldable, g, i, j, len, nonBoundVert, nonBoundVertForCrimp, pairs, ref, ref1, vertices, verticesNum, vertices_coords;
    vertices_coords = creasePattern.vertices_coords;
    edges_vertices = creasePattern.edges_vertices;
    edges_assignment = creasePattern.edges_assignment;
    verticesNum = vertices_coords.length;
    vertices = getEdge(verticesNum, edges_vertices);
    nonBoundVert = getNonBoundVert(edges_assignment, verticesNum, vertices, edges_vertices);
    nonBoundVert = computeAngle(nonBoundVert, vertices_coords);
    if (kawasakiCheck(nonBoundVert)) {
      if (Object.keys(nonBoundVert).length === 1) {
        singleVertAssignMV(nonBoundVert);
        console.log(edges_assignment);
        return edges_assignment;
      } else {
        ref = makeCopy(nonBoundVert), nonBoundVertForCrimp = ref[0], edgeList = ref[1];
        console.log(nonBoundVertForCrimp);
        pairs = findPairs(nonBoundVertForCrimp);
        g = makeGraph(pairs);
        ref1 = checkFlatFoldability(nonBoundVert, pairs, edgeList), flatFoldable = ref1[0], components = ref1[1], g = ref1[2];
        if (flatFoldable) {
          CPAssignMV(edges_assignment, components, g);
          for (i = j = 0, len = edges_assignment.length; j < len; i = ++j) {
            edge = edges_assignment[i];
            if (edge === "U") {
              edges_assignment[i] = "M";
            }
          }
          console.log(edges_assignment);
          return edges_assignment;
        }
      }
    }
    return null;
  };

  $(document).ready(function() {
    var boundries, creases, mode, svg, vertices;
    mode = $("input:checked").val();
    svg = d3.select("#svg_wrapper").append("svg").attr("width", "100%").attr("height", 600).attr("xmlns", "http://www.w3.org/2000/svg");
    creases = svg.append("g").attr("stroke-width", 3).attr("stroke", "gray");
    boundries = svg.append("g").attr("stroke-width", 3).attr("stroke", "blue");
    vertices = svg.append("g").attr("fill", "black").attr("id", "vertices");
    $(".btn-group-vertical").change(function() {
      var firstEdge, firstVert, length;
      mode = $("input:checked").val();
      if (mode === "add_vertex") {
        enableAddVertex(vertices);
      } else {
        disableAddVertex();
      }
      if (mode === "add_crease") {
        firstVert = false;
        enableAddCrease(creases);
      } else if (mode === "add_boundary") {
        firstVert = false;
        enableAddBoundary(boundries);
      } else if (mode === "same_x") {
        firstVert = false;
        same("x");
      } else if (mode === "same_y") {
        firstVert = false;
        same("y");
      } else if (mode === "same_length_x") {
        firstVert = false;
        firstEdge = false;
        length = 0;
        sameLength("x");
      } else if (mode === "same_length_y") {
        firstVert = false;
        firstEdge = false;
        length = 0;
        sameLength("y");
      } else if (mode === "delete") {
        enableDeleteElt();
      } else {
        disableClickEvent();
      }
      if (mode === "clear") {
        return clearSVG();
      }
    });
    $("#file").change(function(e) {
      return importFile(e.target.files[0]);
    });
    $("#check").click(function() {
      var creasePattern;
      clean();
      creasePattern = makeData();
      return creasePattern = makeFace();
    });
    $("#solve").click(function() {
      if (solve(creasePattern)) {
        return alert("Download your FOLD format M-V assignment!");
      }
    });
    return $("#downloadCP").click(function() {
      return downloadCP(creasePattern);
    });
  });

  vertexNum = 0;

  edgeNum = 0;

  firstVert = false;

  firstEdge = false;

  xValue = 0;

  yValue = 0;

  length = 0;

  creasePattern = this;

  creasePattern = {};

  data = {};

  moveVert = function(circle, x, y) {
    if (x !== null) {
      circle.attr("cx", x);
      console.log(circle.attr("id"));
      d3.selectAll('line[start = ' + circle.attr("id") + ']').attr("x1", x);
      d3.selectAll('line[end = ' + circle.attr("id") + ']').attr("x2", x);
    }
    if (y !== null) {
      circle.attr("cy", y);
      d3.selectAll('line[start = ' + circle.attr("id") + ']').attr("y1", y);
      return d3.selectAll('line[end = ' + circle.attr("id") + ']').attr("y2", y);
    }
  };

  enableAddVertex = function(g) {
    return d3.select("svg").on("click", function() {
      var circle;
      if (d3.event.target === this) {
        circle = g.append("circle").attr("cx", d3.mouse(this)[0]).attr("cy", d3.mouse(this)[1]).attr("r", 7).attr("id", "v" + vertexNum);
        return vertexNum += 1;
      }
    });
  };

  disableAddVertex = function() {
    return d3.select("svg").on("click", null);
  };

  enableMoveVertex = function() {
    return d3.selectAll("circle").on("mouseover", function() {
      var circle;
      return circle = d3.select(d3.event.target).attr("fill", "red").call(d3.drag().on("drag", function() {
        return moveVert(circle, d3.event.x, d3.event.y);
      }));
    }).on("mouseout", function() {
      var circle;
      return circle = d3.select(d3.event.target).attr("fill", "black");
    });
  };

  disableMoveVertex = function() {
    return d3.selectAll("circle").on("mouseover", function() {
      var circle;
      return circle = d3.select(d3.event.target).call(d3.drag().on("drag", null));
    });
  };

  enableAddCrease = function(creases) {
    var circle;
    return circle = d3.selectAll("circle").on("mouseover", function() {
      return d3.select(d3.event.target).attr("fill", "red").call(d3.drag().on("drag", null));
    }).on("mouseout", function() {
      return circle.attr("fill", "black");
    }).on("click", function() {
      var line, target;
      target = d3.select(d3.event.target);
      if (!firstVert) {
        firstVert = true;
        return line = creases.append("line").attr("x1", target.attr("cx")).attr("y1", target.attr("cy")).attr("x2", target.attr("cx")).attr("y2", target.attr("cy")).attr("start", target.attr("id")).classed("current", true);
      } else {
        line = d3.select(".current").attr("x2", target.attr("cx")).attr("y2", target.attr("cy")).attr("end", target.attr("id")).classed("current", false).classed("U", true);
        return firstVert = false;
      }
    });
  };

  enableAddBoundary = function(creases) {
    var circle;
    return circle = d3.selectAll("circle").on("mouseover", function() {
      return d3.select(d3.event.target).attr("fill", "red").call(d3.drag().on("drag", null));
    }).on("mouseout", function() {
      return circle.attr("fill", "black");
    }).on("click", function() {
      var line, target;
      target = d3.select(d3.event.target);
      if (!firstVert) {
        firstVert = true;
        return line = creases.append("line").attr("x1", target.attr("cx")).attr("y1", target.attr("cy")).attr("x2", target.attr("cx")).attr("y2", target.attr("cy")).attr("start", target.attr("id")).classed("current", true);
      } else {
        line = d3.select(".current").attr("x2", target.attr("cx")).attr("y2", target.attr("cy")).attr("end", target.attr("id")).classed("current", false).classed("B", true);
        return firstVert = false;
      }
    });
  };

  disableClickEvent = function() {
    var circle;
    firstVert = false;
    firstEdge = false;
    circle = d3.selectAll("circle").on("click", null);
    return circle = d3.selectAll("line").on("click", null);
  };

  enableDeleteElt = function() {
    var line;
    d3.selectAll("circle").on("mouseover", function() {
      return d3.select(d3.event.target).attr("fill", "red").call(d3.drag().on("drag", null));
    }).on("mouseout", function() {
      return d3.select(d3.event.target).attr("fill", "black");
    }).on("click", function() {
      var circle;
      circle = d3.select(d3.event.target);
      d3.selectAll('line[start = ' + circle.attr("id") + ']').remove();
      d3.selectAll('line[end = ' + circle.attr("id") + ']').remove();
      return d3.select(d3.event.target).remove();
    });
    return line = d3.selectAll("line").on("mouseover", function() {
      return d3.select(d3.event.target).attr("fill", "red");
    }).on("mouseout", function() {
      return line.attr("fill", "gray");
    }).on("click", function() {
      return d3.select(d3.event.target).remove();
    });
  };

  clearSVG = function() {
    d3.selectAll("circle").remove();
    return d3.selectAll("line").remove();
  };

  same = function(i) {
    var circle;
    return circle = d3.selectAll("circle").on("click", function() {
      var target;
      target = d3.select(d3.event.target);
      if (!firstVert) {
        firstVert = true;
        return xValue = target.attr("c" + i);
      } else {
        firstVert = false;
        if (i === "x") {
          return moveVert(target, xValue, null);
        } else if (i === "y") {
          return moveVert(target, null, xValue);
        }
      }
    }).on("mouseover", function() {
      return d3.select(d3.event.target).attr("fill", "red").call(d3.drag().on("drag", null));
    }).on("mouseout", function() {
      return circle.attr("fill", "black");
    });
  };

  sameLength = function(i) {
    var circle;
    return circle = d3.selectAll("circle").on("click", function() {
      var target;
      target = d3.select(d3.event.target);
      if (firstEdge) {
        firstEdge = false;
        firstVert = false;
        if (i === "x") {
          moveVert(target, Number(xValue) + length, null);
        } else if (i === "y") {
          moveVert(target, null, Number(yValue) + length);
        }
        return length = 0;
      } else if (!firstVert) {
        firstVert = true;
        xValue = target.attr("cx");
        yValue = target.attr("cy");
        if (length !== 0) {
          return firstEdge = true;
        }
      } else {
        firstVert = false;
        console.log(xValue);
        return length = Math.sqrt(Math.pow(Number(target.attr("cx")) - Number(xValue), 2) + Math.pow(Number(target.attr("cy")) - Number(yValue), 2));
      }
    }).on("mouseover", function() {
      return d3.select(d3.event.target).attr("fill", "red").call(d3.drag().on("drag", null));
    }).on("mouseout", function() {
      return circle.attr("fill", "black");
    });
  };

  importFile = function(file) {
    var reader;
    reader = new FileReader();
    reader.readAsText(file);
    return reader.onload = function(e) {
      creasePattern = JSON.parse(e.target.result);
      return console.log(creasePattern);
    };
  };

  clean = function() {
    var edge, edges, i, j, k, len, len1, len2, m, ref, results, start, v, vertex, vertices;
    vertices = d3.selectAll("circle");
    i = 0;
    ref = vertices.nodes();
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      vertex = ref[j];
      v = d3.select(vertex);
      start = v.attr("id");
      edges = d3.selectAll('line[start = ' + start + ']').nodes();
      for (k = 0, len1 = edges.length; k < len1; k++) {
        edge = edges[k];
        d3.select(edge).attr("start-final", i);
      }
      edges = d3.selectAll('line[end = ' + start + ']').nodes();
      for (m = 0, len2 = edges.length; m < len2; m++) {
        edge = edges[m];
        d3.select(edge).attr("end-final", i);
      }
      v.attr("id-final", i);
      results.push(i += 1);
    }
    return results;
  };

  makeData = function() {
    var e, edge, edges, j, k, len, len1, ref, start, v, vertex, vertices;
    creasePattern = {
      file_version: 1,
      file_creator: "Local flat-foldability Tester",
      file_author: "Chang Liu",
      file_class: "creasePattern",
      frame_title: "Local flat-foldability Test Example",
      frame_attributes: ["2D"],
      vertices_coords: [],
      edges_vertices: [],
      edges_assignment: [],
      faces_vertices: []
    };
    vertices = d3.selectAll("circle");
    ref = vertices.nodes();
    for (j = 0, len = ref.length; j < len; j++) {
      vertex = ref[j];
      v = d3.select(vertex);
      creasePattern.vertices_coords.push([Number(v.attr("cx")), Number(v.attr("cy"))]);
      start = v.attr("id-final");
      edges = d3.selectAll('line[start-final = "' + start + '"]').nodes();
      for (k = 0, len1 = edges.length; k < len1; k++) {
        edge = edges[k];
        e = d3.select(edge);
        if (start !== e.attr("end")) {
          creasePattern.edges_vertices.push([Number(start), Number(e.attr("end-final"))]);
          creasePattern.edges_assignment.push(e.attr("class"));
        }
      }
    }
    return creasePattern;
  };

  makeFace = function() {
    var coord1, coord2, coord3, edge, edge2, edges_assignment, edges_vertices, i, j, k, len, len1, len2, m, n, o, ref, ref1, ref2, ref3, vec1, vec2, vert1, vert2, vert3, vertices, verticesNum, vertices_coords;
    vertices_coords = creasePattern.vertices_coords;
    edges_vertices = creasePattern.edges_vertices;
    edges_assignment = creasePattern.edges_assignment;
    verticesNum = vertices_coords.length;
    vertices = {};
    for (i = j = 0, ref = verticesNum - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      vertices[i] = [];
    }
    for (k = 0, len = edges_vertices.length; k < len; k++) {
      edge = edges_vertices[k];
      vertices[edge[0]].push(edge[1]);
      vertices[edge[1]].push(edge[0]);
    }
    for (vert1 = m = 0, ref1 = verticesNum - 1; 0 <= ref1 ? m <= ref1 : m >= ref1; vert1 = 0 <= ref1 ? ++m : --m) {
      coord1 = vertices_coords[vert1];
      ref2 = vertices[vert1];
      for (n = 0, len1 = ref2.length; n < len1; n++) {
        edge = ref2[n];
        vert2 = edge;
        coord2 = vertices_coords[vert2];
        ref3 = vertices[vert2];
        for (o = 0, len2 = ref3.length; o < len2; o++) {
          edge2 = ref3[o];
          vert3 = edge2;
          coord3 = vertices_coords[vert3];
          vec1 = [coord2[0] - coord1[0], coord2[1] - coord1[1]];
          vec2 = [coord3[0] - coord2[0], coord3[1] - coord2[1]];
          if (((vec1[0] * vec2[1] - vec1[1] * vec2[0]) > 0) && (indexOf.call(vertices[vert3], vert1) >= 0)) {
            if (((vert1 > vert2 && vert2 > vert3)) || ((vert1 < vert2 && vert2 < vert3))) {
              creasePattern.faces_vertices.push([vert1, vert2, vert3]);
              break;
            }
          }
        }
      }
    }
    return console.log(creasePattern);
  };

  downloadCP = function(creasePattern) {
    var a, blob, json, url;
    json = JSON.stringify(creasePattern);
    blob = new Blob([json], {
      type: "application/json"
    });
    url = URL.createObjectURL(blob);
    a = $('#downloadLink');
    a.attr('download', "creasePattern.json").attr('href', url);
    return document.getElementById('downloadLink').click();
  };

}).call(this);
